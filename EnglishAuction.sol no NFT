// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "https://raw.githubusercontent.com/Tylerlingg/Single-NFT-Auction/main/images/ERC721Holder.sol";

contract EnglishAuction is SafeERC721 {
    address payable public immutable owner;
    address payable public immutable creator;
    uint256 public immutable royaltyPercentage;
    uint256 public immutable start;
    uint256 public immutable end;
    uint256 public currentHighestBid;
    address public currentHighestBidder;
    bool public ended;
    IERC721 public nft;
    uint256 public tokenId; // Add tokenId variable
    bool private _hasFinalized;

    event NewHighestBid(address indexed bidder, uint256 amount);
    event BidOutbid(address indexed outbidBidder, uint256 newHighestBid);
    event AuctionEnded(address indexed winner, uint256 amount);
    event AuctionFinalized(address indexed winner, uint256 amount);
    event NFTTransferred(address indexed from, address indexed to, uint256 indexed tokenId);
    
    modifier onlyNotTransferred() {
        require(nft.ownerOf(tokenId) != address(this), "NFT already transferred");
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Caller is not the auction owner");
        _;
    }
    modifier auctionEnded() {
        require(block.timestamp >= end, "Auction is still ongoing");
        _;
    }

    constructor(
        uint256 _royaltyPercentage,
        uint256 _start,
        uint256 _end,
        address _nftAddress,
        uint256 _tokenId // Add tokenId parameter
    ) {
        require(_start > block.timestamp, "Start time must be in the future.");
        require(_end > _start, "End time must be after start time.");
        require(royaltyPercentage == 10, "Royalty percentage will be 10% of the highest bid"); 

        owner = payable(msg.sender);
        creator = payable(msg.sender);

        royaltyPercentage = _royaltyPercentage;
        start = _start;
        end = _end;
        nft = IERC721(_nftAddress);
        tokenId = _tokenId;
    }

    // Transfer the NFT to the contract manually
    function transferNFT() external onlyOwner onlyNotTransferred {
        // Get the current owner of the NFT
        address from = nft.ownerOf(tokenId);
        // Transfer the NFT to the contract
        nft.transferFrom(from, address(this), tokenId);
        // Emit an event
        emit NFTTransferred(from, address(this), tokenId);
    }
        // Define a modifier that checks that the NFT has not been transferred to the contract already
    modifier onlyNotTransferred() {
        require(
            nft.ownerOf(tokenId) != address(this),
            "NFT already transferred"
        );
        _;
    }
    // Define an event that notifies of the NFT transfer
    event NFTTransferred(
        address indexed from,
        address indexed to,
        uint256 indexed tokenId
    );

    modifier onlyBefore(uint _time) {
        require(
            block.timestamp < _time,
            "Operation not allowed after the specified time"
        );
        _;
    }

    modifier onlyNotOwner() {
        require(
            msg.sender != owner,
            "Operation not allowed for the contract owner"
        );
        _;
    }

    function placeBid() external payable onlyBefore(end) onlyNotOwner {
        // Check that the bid is higher than the current highest bid
        if (msg.value <= currentHighestBid) {
            revert("Bid too low");
        }
        
         // Ensure the bidder's address isn't the zero address
        require(msg.sender != address(0), "Bidder address must not be the zero address");
        
        // Refund the previous highest bidder 
        if (currentHighestBid != 0) {
            payable(currentHighestBidder).transfer(currentHighestBid);
        }
        
        // Update the highest bid and bidder variables
        currentHighestBid = msg.value;
        currentHighestBidder = msg.sender;

        // Emit an event to notify the participants and observers of the new highest bid
        emit NewHighestBid(msg.sender, msg.value);
    }
    function endAuction() external onlyOwner {
        require(!ended, "Auction has already ended.");
        require(block.timestamp >= end, "Auction has not ended yet.");

        ended = true;

        emit AuctionEnded(currentHighestBidder, currentHighestBid);
    }

    }

    function finalize() public onlyOwner auctionEnded {
        require(!_hasFinalized, "Auction has already been finalized.");
        require(ended, "Auction has not ended yet.");

        // Calculate the royalty amount
        uint256 royaltyAmount = (currentHighestBid * royaltyPercentage) / 100;

        // Send the royalty amount to the creator
        creator.transfer(royaltyAmount);

        // Calculate the remaining total
        uint256 remainingTotal = currentHighestBid - royaltyAmount;

        // Send remaining funds to owner
        owner.transfer(remainingTotal);

        // Transfer the NFT to the winner
        safeTransferFrom(nft, address(this), currentHighestBidder, tokenId);

        // Set hasFinalized to true
        _hasFinalized = true;

        emit AuctionFinalized(currentHighestBidder, currentHighestBid);
    }
    
